========================================
database.py
========================================
# from pymongo import MongoClient
# from pymongo.errors import ConnectionFailure
# from datetime import datetime

# class Database:
#     def __init__(self, mongo_uri="mongodb+srv://akshayareddy:akshaya20@clusterprac.w63oe.mongodb.net/?retryWrites=true&w=majority&appName=Clusterprac", 
#                  db_name="parksense", collection_name="car_logs"):
#         try:
#             self.client = MongoClient(mongo_uri)
#             self.db = self.client[db_name]
#             self.collection = self.db[collection_name]
#             self.client.admin.command('ping')  # Test the connection
#             print("MongoDB Atlas connection successful!")
#         except ConnectionFailure:
#             print("MongoDB Atlas connection failed! Please check the connection string or network.")
#             exit(1)

#     def upsert_number_plate(self, number_plate):
#         """Upsert number plate with timestamp."""
#         result = self.collection.update_one(
#             {"number_plate": number_plate},
#             {
#                 "$set": {
#                     "number_plate": number_plate,
#                     "timestamp": datetime.utcnow()
#                 }
#             },
#             upsert=True
#         )
#         return result.modified_count > 0 or result.upserted_id is not None

#     def check_number_plate(self, number_plate):
#         """Check if number plate exists in the database."""
#         return self.collection.find_one({"number_plate": number_plate}) is not None

#     def close(self):
#         """Close MongoDB connection."""
#         self.client.close()

from pymongo import MongoClient
from pymongo.errors import ConnectionFailure
from datetime import datetime

class Database:
    def __init__(self, mongo_uri="mongodb+srv://akshayareddy:akshaya20@clusterprac.w63oe.mongodb.net/?retryWrites=true&w=majority&appName=Clusterprac", 
                 db_name="parksense", collection_name="car_logs"):
        try:
            # Jetson Nano may have limited resources, reduce connection timeout
            self.client = MongoClient(mongo_uri, serverSelectionTimeoutMS=5000)  # 5-second timeout
            self.db = self.client[db_name]
            self.collection = self.db[collection_name]
            self.client.admin.command('ping')  # Test the connection
            print("MongoDB Atlas connection successful!")
        except ConnectionFailure as e:
            print(f"MongoDB Atlas connection failed! Error: {e}")
            print("Please check the connection string, network, or MongoDB Atlas status.")
            exit(1)
        except Exception as e:
            print(f"Unexpected error during MongoDB connection: {e}")
            exit(1)

    def upsert_number_plate(self, number_plate):
        """Upsert number plate with timestamp."""
        try:
            result = self.collection.update_one(
                {"number_plate": number_plate},
                {
                    "$set": {
                        "number_plate": number_plate,
                        "timestamp": datetime.utcnow()
                    }
                },
                upsert=True
            )
            return result.modified_count > 0 or result.upserted_id is not None
        except Exception as e:
            print(f"Failed to upsert number plate {number_plate}: {e}")
            return False

    def check_number_plate(self, number_plate):
        """Check if number plate exists in the database."""
        try:
            return self.collection.find_one({"number_plate": number_plate}) is not None
        except Exception as e:
            print(f"Failed to check number plate {number_plate}: {e}")
            return False

    def close(self):
        """Close MongoDB connection."""
        try:
            self.client.close()
            print("MongoDB connection closed.")
        except Exception as e:
            print(f"Error closing MongoDB connection: {e}")

if __name__ == "__main__":
    try:
        print("trying")
        # Initialize the database
        db = Database(
            mongo_uri="mongodb+srv://akshayareddy:akshaya20@clusterprac.w63oe.mongodb.net/?retryWrites=true&w=majority&appName=Clusterprac",
            db_name="parksense",
            collection_name="car_logs"
        )
        
        # Test upserting a sample number plate
        test_plate = "TEST1234"
        print(f"\nTesting upsert for number plate: {test_plate}")
        upsert_result = db.upsert_number_plate(test_plate)
        if upsert_result:
            print(f"Successfully upserted number plate: {test_plate}")
        else:
            print(f"Failed to upsert number plate: {test_plate}")
        
        # Test checking if the number plate exists
        print(f"\nChecking if number plate {test_plate} exists")
        exists = db.check_number_plate(test_plate)
        if exists:
            print(f"Number plate {test_plate} found in database.")
        else:
            print(f"Number plate {test_plate} not found in database.")
        
        # Test checking a non-existent number plate
        test_plate_nonexistent = "FAKE9999"
        print(f"\nChecking if number plate {test_plate_nonexistent} exists")
        exists = db.check_number_plate(test_plate_nonexistent)
        if exists:
            print(f"Number plate {test_plate_nonexistent} found in database.")
        else:
            print(f"Number plate {test_plate_nonexistent} not found in database.")
        
    except Exception as e:
        print(f"Test failed: {e}")
    finally:
        # Close the database connection
        db.close()

========================================
extract.py
========================================
import cv2
import pytesseract
import numpy as np

pytesseract.pytesseract.tesseract_cmd = "/usr/bin/tesseract"  # Change path if on Windows

class NumberPlateExtractor:
    """Class to extract text from number plate images using pytesseract."""

    def __init__(self, tesseract_cmd=None):
        if tesseract_cmd:
            pytesseract.pytesseract.tesseract_cmd = tesseract_cmd

    def preprocess_plate(self, img):
        """Preprocess the number plate image to improve OCR accuracy."""
        try:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            thresh = cv2.adaptiveThreshold(
                gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                cv2.THRESH_BINARY_INV, 11, 2
            )
            blurred = cv2.GaussianBlur(thresh, (3, 3), 0)
            return blurred
        except Exception as e:
            print(f"Error in preprocessing number plate: {e}")
            return img  # fallback

    def process_plate(self, full_image, box):
        """
        Extract and OCR the number plate from the image using the bounding box.

        Args:
            full_image (np.ndarray): Original image.
            box (tuple): Bounding box (x1, y1, x2, y2).

        Returns:
            str: Extracted plate text.
        """
        try:
            x1, y1, x2, y2 = map(int, box)
            plate_img = full_image[y1:y2, x1:x2]
            preprocessed = self.preprocess_plate(plate_img)
            text = pytesseract.image_to_string(preprocessed, config='--psm 7')
            clean_text = ''.join(filter(str.isalnum, text))
            return clean_text if clean_text else None
        except Exception as e:
            print(f"Error in extracting plate text: {e}")
            return None



========================================
rover_movement.py
========================================
import jetson_utils
import sys
import os
import time
import math
from dronekit import connect, VehicleMode

class Rover:
    def __init__(self, serial_port="/dev/ttyUSB0", baud_rate=57600, input_uri="/dev/video0", output_uri="display://0", width=640, height=480):
        self.serial_port = serial_port
        self.baud_rate = baud_rate
        self.vehicle = None
        self.input_stream = None
        self.output_stream = None
        self.width = width
        self.height = height
        
        # RC channel mappings and control parameters
        self.THROTTLE_CH = 3
        self.STEERING_CH = 1
        self.CENTER = 1500
        self.TURN_AMOUNT = 85
        self.THROTTLE_NEUTRAL = 1500
        self.THROTTLE_MAX = 2000
        self.THROTTLE_MIN = 1000
        self.current_throttle = self.THROTTLE_NEUTRAL
        self.current_steering = self.CENTER
        self.initial_yaw = None
        self.drift_threshold = 1.0
        self.angular_velocity = 30.0

        # Connect to the rover
        self._connect_rover()

    def _connect_rover(self):
        """Initialize connection to the rover using DroneKit."""
        if not os.path.exists(self.serial_port):
            print(f"Error: Serial port {self.serial_port} does not exist.")
            sys.exit(1)
        
        try:
            with open(self.serial_port, 'r'):
                pass
        except PermissionError:
            print(f"Error: Permission denied for {self.serial_port}. Run with sudo or add user to 'dialout' group.")
            sys.exit(1)
        
        try:
            self.vehicle = connect(self.serial_port, baud=self.baud_rate, wait_ready=False)
            print(f"Connected to rover on {self.serial_port}")
            
            # Set GUIDED mode
            self.vehicle.mode = VehicleMode("GUIDED")
            timeout = 10
            start_time = time.time()
            while not self.vehicle.mode.name == "GUIDED" and time.time() - start_time < timeout:
                print("Waiting for GUIDED mode...")
                time.sleep(1)
            if self.vehicle.mode.name != "GUIDED":
                print("Error: Failed to set GUIDED mode.")
                self.cleanup()
                sys.exit(1)
            
            # Arm the rover
            self.vehicle.armed = True
            start_time = time.time()
            while not self.vehicle.armed and time.time() - start_time < timeout:
                print("Waiting for arming...")
                time.sleep(1)
            if not self.vehicle.armed:
                print("Error: Failed to arm rover.")
                self.cleanup()
                sys.exit(1)
            print("Rover armed successfully.")
        except Exception as e:
            print(f"Connection failed: {e}")
            self.cleanup()
            sys.exit(1)

    def mount_camera(self, input_uri="/dev/video0", output_uri="display://0"):
        """Mount and initialize the USB camera with specified input and output URIs."""
        if self.input_stream is not None or self.output_stream is not None:
            print("Camera already mounted.")
            return False
        
        if not os.path.exists(input_uri):
            print(f"Error: USB camera device {input_uri} does not exist. Check available devices with 'ls /dev/video*'.")
            return False
        
        try:
            self.input_stream = jetson_utils.videoSource(input_uri, argv=[f"--input-width={self.width}", f"--input-height={self.height}"])
            self.output_stream = jetson_utils.videoOutput(output_uri, argv=sys.argv)
            print(f"USB camera mounted and initialized successfully on {input_uri}.")
            return True
        except Exception as e:
            print(f"Camera mount error: {e}")
            self.input_stream = None
            self.output_stream = None
            return False

    def dismount_camera(self):
        """Dismount and close the camera streams."""
        if self.input_stream is None and self.output_stream is None:
            print("No camera mounted.")
            return False
        try:
            if self.input_stream:
                self.input_stream.Close()
                self.input_stream = None
            if self.output_stream:
                self.output_stream.Close()
                self.output_stream = None
            print("Camera dismounted and streams closed.")
            return True
        except Exception as e:
            print(f"Camera dismount error: {e}")
            return False

    def capture_image(self, segment, distance):
        """Capture and save an image for inference."""
        if self.input_stream is None or self.output_stream is None:
            print("Error: Camera not mounted. Call mount_camera() first.")
            return None
        
        try:
            img = self.input_stream.Capture()
            if img is not None:
                self.output_stream.Render(img)
                self.output_stream.SetStatus(f"Image Capture | Segment {segment} | {distance:.1f} meters")
                filename = f"captured_images/capture_segment_{segment}_{distance:.1f}m.jpg"
                os.makedirs("captured_images", exist_ok=True)
                jetson_utils.saveImage(filename, img)
                print(f"Image saved as {filename}")
                return filename
            else:
                print("Error: Failed to capture image.")
                return None
        except Exception as e:
            print(f"Failed to save image: {e}")
            return None

    def get_yaw(self):
        """Read current yaw in degrees."""
        try:
            attitude = self.vehicle.attitude
            yaw_degrees = attitude.yaw * (180.0 / math.pi)
            return yaw_degrees
        except Exception as e:
            print(f"Warning: Could not retrieve yaw: {e}")
            return None

    def send_rc_override(self, throttle, steering):
        """Send RC override commands to the rover."""
        try:
            self.vehicle.channels.overrides = {
                self.STEERING_CH: steering,
                self.THROTTLE_CH: throttle
            }
        except Exception as e:
            print(f"Error sending RC override: {e}")

    def correct_drift(self):
        """Correct rover drift based on yaw deviation."""
        yaw = self.get_yaw()
        if self.initial_yaw is None or yaw is None:
            return
        
        yaw_deviation = yaw - self.initial_yaw
        if yaw_deviation > 180:
            yaw_deviation -= 360
        elif yaw_deviation < -180:
            yaw_deviation += 360
        
        if yaw_deviation > self.drift_threshold:
            self.current_steering = self.CENTER + self.TURN_AMOUNT
            print(f"Correcting left. Yaw deviation: {yaw_deviation:.2f}°")
        elif yaw_deviation < -self.drift_threshold:
            self.current_steering = self.CENTER - self.TURN_AMOUNT
            print(f"Correcting right. Yaw deviation: {yaw_deviation:.2f}°")
        else:
            self.current_steering = self.CENTER
        self.send_rc_override(self.current_throttle, self.current_steering)

    def forward(self, distance, velocity=1.0, throttle_percent=50):
        """Move the rover forward by a specified distance."""
        if not self.vehicle or not self.vehicle.armed:
            print("Error: Rover not connected or not armed.")
            return
        
        segment_duration = distance / velocity
        self.current_throttle = int(self.THROTTLE_NEUTRAL + (self.THROTTLE_MAX - self.THROTTLE_NEUTRAL) * (throttle_percent / 100))
        self.initial_yaw = self.get_yaw()
        
        print(f"Moving forward {distance} meters...")
        start_time = time.time()
        while time.time() - start_time < segment_duration:
            self.correct_drift()
            current_yaw = self.get_yaw()
            if current_yaw is not None:
                print(f"\rTime: {time.time() - start_time:.1f}s, Yaw: {current_yaw:.2f}°", end='')
            time.sleep(0.1)
        
        self.current_throttle = self.THROTTLE_NEUTRAL
        self.send_rc_override(self.current_throttle, self.CENTER)
        self.vehicle.channels.overrides = {}
        print("\nForward movement complete.")
        time.sleep(0.5)

    def backward(self, distance, velocity=1.0, throttle_percent=50):
        """Move the rover backward by a specified distance."""
        if not self.vehicle or not self.vehicle.armed:
            print("Error: Rover not connected or not armed.")
            return
        
        segment_duration = distance / velocity
        self.current_throttle = int(self.THROTTLE_NEUTRAL - (self.THROTTLE_NEUTRAL - self.THROTTLE_MIN) * (throttle_percent / 100))
        self.initial_yaw = self.get_yaw()
        
        print(f"Moving backward {distance} meters...")
        start_time = time.time()
        while time.time() - start_time < segment_duration:
            self.correct_drift()
            current_yaw = self.get_yaw()
            if current_yaw is not None:
                print(f"\rTime: {time.time() - start_time:.1f}s, Yaw: {current_yaw:.2f}°", end='')
            time.sleep(0.1)
        
        self.current_throttle = self.THROTTLE_NEUTRAL
        self.send_rc_override(self.current_throttle, self.CENTER)
        self.vehicle.channels.overrides = {}
        print("\nBackward movement complete.")
        time.sleep(0.5)

    def reverse(self, distance, velocity=1.0, throttle_percent=50):
        """Reverse the rover by a specified distance (alias for backward)."""
        self.backward(distance, velocity, throttle_percent)

    def left(self, angle, angular_velocity=None):
        """Turn the rover left by a specified angle with gentle steering."""
        if not self.vehicle or not self.vehicle.armed:
            print("Error: Rover not connected or not armed.")
            return
        
        if angular_velocity is None:
            angular_velocity = self.angular_velocity / 2
        duration = abs(angle) / angular_velocity
        self.current_steering = self.CENTER - self.TURN_AMOUNT
        self.current_throttle = self.THROTTLE_NEUTRAL
        
        print(f"Turning left by {angle} degrees...")
        start_yaw = self.get_yaw()
        if start_yaw is None:
            print("Cannot turn: Yaw unavailable.")
            return
        
        start_time = time.time()
        target_yaw = (start_yaw - angle) % 360
        while time.time() - start_time < duration:
            self.send_rc_override(self.current_throttle, self.current_steering)
            current_yaw = self.get_yaw()
            if current_yaw is None:
                continue
            yaw_diff = (current_yaw - target_yaw) % 360
            if yaw_diff > 180:
                yaw_diff -= 360
            if abs(yaw_diff) < 2:
                break
            print(f"\rCurrent Yaw: {current_yaw:.2f}°, Target Yaw: {target_yaw:.2f}°", end='')
            time.sleep(0.1)
        
        self.current_steering = self.CENTER
        self.send_rc_override(self.current_throttle, self.CENTER)
        self.vehicle.channels.overrides = {}
        print("\nLeft turn complete.")
        time.sleep(0.5)

    def right(self, angle, angular_velocity=None):
        """Turn the rover right by a specified angle with gentle steering."""
        if not self.vehicle or not self.vehicle.armed:
            print("Error: Rover not connected or not armed.")
            return
        
        if angular_velocity is None:
            angular_velocity = self.angular_velocity / 2
        duration = abs(angle) / angular_velocity
        self.current_steering = self.CENTER + self.TURN_AMOUNT
        self.current_throttle = self.THROTTLE_NEUTRAL
        
        print(f"Turning right by {angle} degrees...")
        start_yaw = self.get_yaw()
        if start_yaw is None:
            print("Cannot turn: Yaw unavailable.")
            return
        
        start_time = time.time()
        target_yaw = (start_yaw + angle) % 360
        while time.time() - start_time < duration:
            self.send_rc_override(self.current_throttle, self.current_steering)
            current_yaw = self.get_yaw()
            if current_yaw is None:
                continue
            yaw_diff = (current_yaw - target_yaw) % 360
            if yaw_diff > 180:
                yaw_diff -= 360
            if abs(yaw_diff) < 2:
                break
            print(f"\rCurrent Yaw: {current_yaw:.2f}°, Target Yaw: {target_yaw:.2f}°", end='')
            time.sleep(0.1)
        
        self.current_steering = self.CENTER
        self.send_rc_override(self.current_throttle, self.CENTER)
        self.vehicle.channels.overrides = {}
        print("\nRight turn complete.")
        time.sleep(0.5)

    def spin_left(self, angle, angular_velocity=None):
        """Spin the rover left by a specified angle (faster than turn)."""
        if not self.vehicle or not self.vehicle.armed:
            print("Error: Rover not connected or not armed.")
            return
        
        if angular_velocity is None:
            angular_velocity = self.angular_velocity
        duration = abs(angle) / angular_velocity
        self.current_steering = self.CENTER - self.TURN_AMOUNT * 2
        self.current_throttle = self.THROTTLE_NEUTRAL
        
        print(f"Spinning left by {angle} degrees...")
        start_yaw = self.get_yaw()
        if start_yaw is None:
            print("Cannot spin: Yaw unavailable.")
            return
        
        start_time = time.time()
        target_yaw = (start_yaw - angle) % 360
        while time.time() - start_time < duration:
            self.send_rc_override(self.current_throttle, self.current_steering)
            current_yaw = self.get_yaw()
            if current_yaw is None:
                continue
            yaw_diff = (current_yaw - target_yaw) % 360
            if yaw_diff > 180:
                yaw_diff -= 360
            if abs(yaw_diff) < 2:
                break
            print(f"\rCurrent Yaw: {current_yaw:.2f}°, Target Yaw: {target_yaw:.2f}°", end='')
            time.sleep(0.1)
        
        self.current_steering = self.CENTER
        self.send_rc_override(self.current_throttle, self.CENTER)
        self.vehicle.channels.overrides = {}
        print("\nLeft spin complete.")
        time.sleep(0.5)

    def spin_right(self, angle, angular_velocity=None):
        """Spin the rover right by a specified angle (faster than turn)."""
        if not self.vehicle or not self.vehicle.armed:
            print("Error: Rover not connected or not armed.")
            return
        
        if angular_velocity is None:
            angular_velocity = self.angular_velocity
        duration = abs(angle) / angular_velocity
        self.current_steering = self.CENTER + self.TURN_AMOUNT * 2
        self.current_throttle = self.THROTTLE_NEUTRAL
        
        print(f"Spinning right by {angle} degrees...")
        start_yaw = self.get_yaw()
        if start_yaw is None:
            print("Cannot spin: Yaw unavailable.")
            return
        
        start_time = time.time()
        target_yaw = (start_yaw + angle) % 360
        while time.time() - start_time < duration:
            self.send_rc_override(self.current_throttle, self.current_steering)
            current_yaw = self.get_yaw()
            if current_yaw is None:
                continue
            yaw_diff = (current_yaw - target_yaw) % 360
            if yaw_diff > 180:
                yaw_diff -= 360
            if abs(yaw_diff) < 2:
                break
            print(f"\rCurrent Yaw: {current_yaw:.2f}°, Target Yaw: {target_yaw:.2f}°", end='')
            time.sleep(0.1)
        
        self.current_steering = self.CENTER
        self.send_rc_override(self.current_throttle, self.CENTER)
        self.vehicle.channels.overrides = {}
        print("\nRight spin complete.")
        time.sleep(0.5)

    def cleanup(self):
        """Disarm the rover and close camera and vehicle connections."""
        if self.vehicle:
            self.vehicle.channels.overrides = {}
            self.vehicle.armed = False
            print("Rover disarmed.")
            self.vehicle.close()
            self.vehicle = None
        self.dismount_camera()

if __name__ == "__main__":
    try:
        rover = Rover()
        rover.mount_camera()
        rover.forward(2.0)
        rover.backward(1.0)
        rover.reverse(1.0)
        rover.left(45)
        rover.right(45)
        rover.spin_left(90)
        rover.capture_image(1, 2.0)
    finally:
        rover.cleanup()


========================================
model_loader.py
========================================
import onnxruntime as ort
import os
from pathlib import Path
# hehe
class ModelLoader:
    """Class to load and manage ONNX models for car and number plate detection."""
    
    def __init__(self, car_model_path: str, np_model_path: str):
        """
        Initialize the ModelLoader with paths to car and number plate ONNX models.
        
        Args:
            car_model_path (str): Path to the car detection ONNX model.
            np_model_path (str): Path to the number plate detection ONNX model.
        
        Raises:
            FileNotFoundError: If model files do not exist.
            RuntimeError: If model loading fails.
        """
        # Validate model paths
        self.car_model_path = Path(car_model_path)
        self.np_model_path = Path(np_model_path)
        
        if not self.car_model_path.exists():
            raise FileNotFoundError(f"Car model file not found: {self.car_model_path}")
        if not self.np_model_path.exists():
            raise FileNotFoundError(f"Number plate model file not found: {self.np_model_path}")
        
        # Initialize inference sessions
        self.car_session = None
        self.np_session = None
        self._load_models()
    
    def _load_models(self):
        """Load the ONNX models into inference sessions."""
        try:
            self.car_session = ort.InferenceSession(str(self.car_model_path))
            print(f"Successfully loaded car detection model: {self.car_model_path}")
        except Exception as e:
            raise RuntimeError(f"Failed to load car detection model: {str(e)}")
        
        try:
            self.np_session = ort.InferenceSession(str(self.np_model_path))
            print(f"Successfully loaded number plate detection model: {self.np_model_path}")
        except Exception as e:
            raise RuntimeError(f"Failed to load number plate detection model: {str(e)}")
    
    def get_car_session(self):
        """
        Get the car detection model inference session.
        
        Returns:
            ort.InferenceSession: The car detection model session.
        """
        return self.car_session
    
    def get_np_session(self):
        """
        Get the number plate detection model inference session.
        
        Returns:
            ort.InferenceSession: The number plate detection model session.
        """
        return self.np_session
    
    def get_car_input_name(self):
        """
        Get the input name for the car detection model.
        
        Returns:
            str: The input name for the car detection model.
        """
        return self.car_session.get_inputs()[0].name
    
    def get_np_input_name(self):
        """
        Get the input name for the number plate detection model.
        
        Returns:
            str: The input name for the number plate detection model.
        """
        return self.np_session.get_inputs()[0].name

if __name__ == "__main__":
    # Example usage for testing
    model_loader = ModelLoader(
        car_model_path="../models/car.onnx",
        np_model_path="../models//np.onnx"
    )
    print("Car model input name:", model_loader.get_car_input_name())
    print("Number plate model input name:", model_loader.get_np_input_name())


========================================
rover.py
========================================
# from rover_movement import Rover as BaseRover
# from model_loader import ModelLoader
# from model_inference import ModelInference
# import os

# class Rover(BaseRover):
#     def __init__(self, serial_port="/dev/ttyUSB0", baud_rate=57600, input_uri="/dev/video0", 
#                  output_uri="display://0", width=640, height=480, 
#                  car_model_path="models/car.onnx", np_model_path="models/np.onnx"):
#         """Initialize the Rover with movement, camera, and inference capabilities."""
#         # Initialize the base Rover class for movement and camera control
#         super().__init__(serial_port=serial_port, baud_rate=baud_rate, input_uri=input_uri, 
#                          output_uri=output_uri, width=width, height=height)
        
#         # Initialize model inference
#         try:
#             self.model_loader = ModelLoader(car_model_path, np_model_path)
#             self.inference = ModelInference(self.model_loader, conf_threshold=0.5, iou_threshold=0.45)
#             print("Model inference initialized successfully.")
#         except Exception as e:
#             print(f"Failed to initialize model inference: {e}")
#             self.cleanup()
#             raise

#     def run_inference(self, img_path, output_path):
#         """Run car and number plate detection on a captured image."""
#         try:
#             car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids = self.inference.infer(
#                 img_path=img_path, output_path=output_path
#             )
#             print(f"Car detections: {len(car_boxes)}")
#             print(f"Number plate detections: {len(np_boxes)}")
#             return car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids
#         except Exception as e:
#             print(f"Inference failed: {e}")
#             return None

#     def perform_mission(self, segment=1, distance=2.0):
#         """Execute a sample mission: move, capture image, and run inference."""
#         try:
#             # Mount the camera
#             if not self.mount_camera():
#                 print("Failed to mount camera. Aborting mission.")
#                 return
            
#             # Move forward
#             self.forward(distance)
            
#             # Capture an image
#             img_path = self.capture_image(segment, distance)
#             if img_path is None:
#                 print("Failed to capture image. Skipping inference.")
#                 return
            
#             # Run inference on the captured image
#             output_path = f"captured_images/output_segment_{segment}_{distance:.1f}m.jpg"
#             self.run_inference(img_path, output_path)
            
#         except Exception as e:
#             print(f"Mission failed: {e}")
#         finally:
#             self.dismount_camera()

# if __name__ == "__main__":
#     try:
#         # Initialize the rover
#         rover = Rover()
        
#         # Perform a sample mission
#         rover.perform_mission(segment=1, distance=2.0)
        
#         # Additional movements for demonstration
#         rover.mount_camera()
#         rover.backward(1.0)
#         rover.reverse(1.0)
#         rover.left(45)
#         rover.right(45)
#         rover.spin_left(90)
#         rover.spin_right(90)
#         rover.capture_image(segment=2, distance=1.0)
        
#     finally:
#         rover.cleanup()

from rover_movement import Rover as BaseRover
from model_loader import ModelLoader
from model_inference import ModelInference
from number_plate_extract import NumberPlateExtractor
from database import Database
import os
import time
import jetson_utils
import cv2
import numpy as np
from datetime import datetime

class Rover(BaseRover):
    def __init__(self, serial_port="/dev/ttyUSB0", baud_rate=57600, input_uri="/dev/video0", 
                 output_uri="display://0", width=640, height=480, 
                 car_model_path="models/car.onnx", np_model_path="models/np.onnx",
                 mongo_uri="mongodb+srv://akshayareddy:akshaya20@clusterprac.w63oe.mongodb.net/?retryWrites=true&w=majority&appName=Clusterprac"):
        """Initialize the Rover with movement, camera, inference, and database capabilities."""
        super().__init__(serial_port=serial_port, baud_rate=baud_rate, input_uri=input_uri, 
                         output_uri=output_uri, width=width, height=height)
        
        try:
            self.model_loader = ModelLoader(car_model_path, np_model_path)
            self.inference = ModelInference(self.model_loader, conf_threshold=0.5, iou_threshold=0.45)
            self.plate_extractor = NumberPlateExtractor()
            print("Model inference and plate extractor initialized successfully.")
        except Exception as e:
            print(f"Failed to initialize model inference or plate extractor: {e}")
            self.cleanup()
            raise
        
        try:
            self.db = Database(mongo_uri=mongo_uri)
            print("Database initialized successfully.")
        except Exception as e:
            print(f"Failed to initialize database: {e}")
            self.cleanup()
            raise
        
        self.detected_plates = []
    
    def process_frame(self, img, segment, distance_covered, total_distance, num_slots):
        """Process a single frame for car and number plate detection, and extract text."""
        try:
            img_np = jetson_utils.cudaToNumpy(img)
            img_np = cv2.cvtColor(img_np, cv2.COLOR_RGBA2BGR)
            temp_path = f"temp_frame_{segment}_{distance_covered:.1f}m.jpg"
            cv2.imwrite(temp_path, img_np)
            
            car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids = self.inference.infer(
                img_path=temp_path, output_path=temp_path
            )
            
            if len(car_boxes) > 0 and len(np_boxes) > 0:
                for box in np_boxes:
                    plate_text = self.plate_extractor.process_plate(img_np, box)
                    if plate_text:
                        slot = int((distance_covered / total_distance) * num_slots) + 1
                        self.detected_plates.append((plate_text, datetime.utcnow(), slot))
                        print(f"Detected plate: {plate_text}, Slot: {slot}, Timestamp: {datetime.utcnow()}")
            
            if os.path.exists(temp_path):
                os.remove(temp_path)
            
            return True
        except Exception as e:
            print(f"Error processing frame: {e}")
            return False
    
    def perform_mission(self, total_distance=10.0, num_slots=5, velocity=1.0, segment_duration=1.0):
        """Execute a mission: move forward, capture video, detect cars and plates, and update database."""
        try:
            if not self.mount_camera():
                print("Failed to mount camera. Aborting mission.")
                return
            
            total_time = total_distance / velocity
            segment_distance = velocity * segment_duration
            distance_covered = 0.0
            segment = 1
            
            print(f"Starting mission: {total_distance}m, {num_slots} slots, velocity {velocity}m/s")
            start_time = time.time()
            
            self.forward(total_distance, velocity=velocity)
            
            while distance_covered < total_distance:
                if self.input_stream is None:
                    print("Camera stream closed unexpectedly.")
                    break
                
                img = self.input_stream.Capture()
                if img is None:
                    print("Failed to capture frame.")
                    time.sleep(0.1)
                    continue
                
                self.output_stream.Render(img)
                self.output_stream.SetStatus(f"Mission | Distance: {distance_covered:.1f}m | Segment {segment}")
                
                self.process_frame(img, segment, distance_covered, total_distance, num_slots)
                
                elapsed_time = time.time() - start_time
                distance_covered = min(elapsed_time * velocity, total_distance)
                segment = int(distance_covered / segment_distance) + 1
                
                time.sleep(0.1)
            
            self.current_throttle = self.THROTTLE_NEUTRAL
            self.send_rc_override(self.current_throttle, self.CENTER)
            self.vehicle.channels.overrides = {}
            print("\nMission movement complete.")
            
            self.verify_and_upsert_plates(num_slots)
            
        except Exception as e:
            print(f"Mission failed: {e}")
        finally:
            self.dismount_camera()
            self.db.close()
    
    def verify_and_upsert_plates(self, num_slots):
        """Verify detected plates against database and upsert new entries."""
        try:
            print("Verifying and upserting detected plates...")
            for plate_text, timestamp, slot in self.detected_plates:
                if slot > num_slots:
                    print(f"Warning: Slot {slot} exceeds number of slots ({num_slots}). Skipping.")
                    continue
                
                exists = self.db.check_number_plate(plate_text)
                if not exists:
                    result = self.db.upsert_number_plate(plate_text)
                    if result:
                        print(f"Added plate {plate_text} to slot {slot} at {timestamp}")
                    else:
                        print(f"Failed to upsert plate {plate_text}")
                else:
                    print(f"Plate { Roveplate_text} already exists in database.")
            
            self.detected_plates = []
        except Exception as e:
            print(f"Error verifying/upserting plates: {e}")
    
    def cleanup(self):
        """Clean up rover, camera, and database connections."""
        super().cleanup()
        try:
            self.db.close()
        except:
            pass

if __name__ == "__main__":
    rover = None
    try:
        # Initialize the rover with test parameters
        rover = Rover(
            serial_port="/dev/ttyUSB0",
            input_uri="/dev/video0",
            car_model_path="../models/car.onnx",
            np_model_path="../models/np.onnx",
            mongo_uri="mongodb+srv://akshayareddy:akshaya20@clusterprac.w63oe.mongodb.net/?retryWrites=true&w=majority&appName=Clusterprac"
        )
        
        # Test mission: 5 meters, 3 slots, 0.5 m/s velocity, 1-second segments
        rover.perform_mission(
            total_distance=5.0,
            num_slots=3,
            velocity=0.5,
            segment_duration=1.0
        )
        
    except Exception as e:
        print(f"Test mission failed: {e}")
    finally:
        if rover is not None:  # Check if rover was instantiated
            rover.cleanup()


========================================
model_inference.py
========================================
import cv2
import numpy as np
from pathlib import Path

class ModelInference:
    """Class to perform inference using car and number plate detection models."""
    
    def __init__(self, model_loader, conf_threshold=0.5, iou_threshold=0.45):
        """
        Initialize the ModelInference with a ModelLoader instance.
        
        Args:
            model_loader: Instance of ModelLoader with loaded ONNX models.
            conf_threshold (float): Confidence threshold for detections.
            iou_threshold (float): IoU threshold for Non-Maximum Suppression.
        """
        self.model_loader = model_loader
        self.conf_threshold = conf_threshold
        self.iou_threshold = iou_threshold
    
    def nms(self, boxes, scores, iou_threshold):
        """Apply Non-Maximum Suppression to filter overlapping bounding boxes.
        
        Args:
            boxes (np.ndarray): Array of bounding boxes [x1, y1, x2, y2].
            scores (np.ndarray): Confidence scores for each box.
            iou_threshold (float): IoU threshold for suppression.
        
        Returns:
            list: Indices of boxes to keep after NMS.
        """
        if len(boxes) == 0:
            return []
        x1, y1, x2, y2 = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3]
        areas = (x2 - x1) * (y2 - y1)
        order = scores.argsort()[::-1]
        keep = []
        while order.size > 0:
            i = order[0]
            keep.append(i)
            xx1 = np.maximum(x1[i], x1[order[1:]])
            yy1 = np.maximum(y1[i], y1[order[1:]])
            xx2 = np.minimum(x2[i], x2[order[1:]])
            yy2 = np.minimum(y2[i], y2[order[1:]])
            w = np.maximum(0, xx2 - xx1)
            h = np.maximum(0, yy2 - yy1)
            inter = w * h
            iou = inter / (areas[i] + areas[order[1:]] - inter)
            inds = np.where(iou <= iou_threshold)[0]
            order = order[inds + 1]
        return keep
    
    def preprocess_image(self, img_path, input_size=(640, 640)):
        """Preprocess an image for model inference.
        
        Args:
            img_path (str): Path to the input image.
            input_size (tuple): Target size for resizing (width, height).
        
        Returns:
            tuple: (original image, preprocessed image, original height, original width)
        
        Raises:
            FileNotFoundError: If image file is not found.
        """
        img_orig = cv2.imread(str(img_path))
        if img_orig is None:
            raise FileNotFoundError(f"Could not load image: {img_path}")
        img_height, img_width = img_orig.shape[:2]
        img = cv2.resize(img_orig, input_size)  # Resize to model input size
        img = img.transpose(2, 0, 1)  # HWC to CHW
        img = img[np.newaxis, ...] / 255.0  # Add batch dimension and normalize
        img = img.astype(np.float32)
        return img_orig, img, img_height, img_width
    
    def run_inference(self, session, input_name, img):
        """Run inference on a model session.
        
        Args:
            session: ONNX Runtime inference session.
            input_name (str): Name of the model input.
            img (np.ndarray): Preprocessed input image.
        
        Returns:
            np.ndarray: Model output.
        """
        return session.run(None, {input_name: img})[0]
    
    def postprocess_detections(self, outputs, img_height, img_width, num_classes):
        """Post-process model outputs to extract bounding boxes, scores, and class IDs.
        
        Args:
            outputs (np.ndarray): Model output [batch, num_boxes, num_classes + 5].
            img_height (int): Original image height.
            img_width (int): Original image width.
            num_classes (int): Number of classes in the model.
        
        Returns:
            tuple: (boxes, scores, class_ids)
        """
        boxes = []
        scores = []
        class_ids = []
        
        for detection in outputs[0]:  # Iterate over detections
            confidence = detection[4]  # Objectness score
            if confidence > self.conf_threshold:
                class_scores = detection[5:]  # Class probabilities
                class_id = np.argmax(class_scores)
                class_score = class_scores[class_id]
                if class_score * confidence > self.conf_threshold:
                    # Extract and scale bounding box
                    center_x, center_y, width, height = detection[0:4]
                    x1 = (center_x - width / 2) * img_width / 640
                    y1 = (center_y - height / 2) * img_height / 640
                    x2 = (center_x + width / 2) * img_width / 640
                    y2 = (center_y + height / 2) * img_height / 640
                    boxes.append([x1, y1, x2, y2])
                    scores.append(confidence * class_score)
                    class_ids.append(class_id)
        
        return np.array(boxes), np.array(scores), class_ids
    
    def draw_detections(self, img, boxes, scores, class_ids, prefix=""):
        """Draw bounding boxes and labels on the image.
        
        Args:
            img (np.ndarray): Original image to draw on.
            boxes (np.ndarray): Bounding boxes [x1, y1, x2, y2].
            scores (np.ndarray): Confidence scores.
            class_ids (list): Class IDs for each detection.
            prefix (str): Prefix for labels (e.g., 'Car' or 'NP').
        
        Returns:
            np.ndarray: Image with drawn bounding boxes.
        """
        for i, box in enumerate(boxes):
            x1, y1, x2, y2 = box.astype(int)
            cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
            label = f"{prefix} Class {class_ids[i]}: {scores[i]:.2f}"
            cv2.putText(img, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        return img
    
    def infer(self, img_path, output_path):
        """Perform inference on an image using both car and number plate models.
        
        Args:
            img_path (str): Path to the input image.
            output_path (str): Path to save the output image with detections.
        
        Returns:
            tuple: (car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids)
        
        Raises:
            RuntimeError: If output image cannot be saved.
        """
        # Preprocess image
        img_orig, img, img_height, img_width = self.preprocess_image(img_path)
        
        # Run car detection
        car_session = self.model_loader.get_car_session()
        car_input_name = self.model_loader.get_car_input_name()
        car_outputs = self.run_inference(car_session, car_input_name, img)
        car_num_classes = car_outputs.shape[2] - 5  # Infer number of classes
        car_boxes, car_scores, car_class_ids = self.postprocess_detections(
            car_outputs, img_height, img_width, car_num_classes
        )
        car_keep = self.nms(car_boxes, car_scores, self.iou_threshold) if len(car_boxes) > 0 else []
        car_boxes = car_boxes[car_keep]
        car_scores = car_scores[car_keep]
        car_class_ids = [car_class_ids[i] for i in car_keep]
        
        # Run number plate detection
        np_session = self.model_loader.get_np_session()
        np_input_name = self.model_loader.get_np_input_name()
        np_outputs = self.run_inference(np_session, np_input_name, img)
        np_num_classes = np_outputs.shape[2] - 5  # Infer number of classes
        np_boxes, np_scores, np_class_ids = self.postprocess_detections(
            np_outputs, img_height, img_width, np_num_classes
        )
        np_keep = self.nms(np_boxes, np_scores, self.iou_threshold) if len(np_boxes) > 0 else []
        np_boxes = np_boxes[np_keep]
        np_scores = np_scores[np_keep]
        np_class_ids = [np_class_ids[i] for i in np_keep]
        
        # Draw detections
        img_orig = self.draw_detections(img_orig, car_boxes, car_scores, car_class_ids, prefix="Car")
        img_orig = self.draw_detections(img_orig, np_boxes, np_scores, np_class_ids, prefix="NP")
        
        # Save output
        if not cv2.imwrite(str(output_path), img_orig):
            raise RuntimeError(f"Failed to save output image: {output_path}")
        print(f"Output saved as {output_path}")
        
        return car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids

if __name__ == "__main__":
    from model_loader import ModelLoader
    
    # Example usage for testing
    model_loader = ModelLoader(
        car_model_path="../models/car.onnx",
        np_model_path="../models//np.onnx"
    )
    inference = ModelInference(model_loader)
    car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids = inference.infer(
        img_path="../captured_images/car1.jpg",
        output_path="../captured_images/output.jpg"
    )
    print("Car detections:", len(car_boxes))
    print("Number plate detections:", len(np_boxes))


========================================
number_plate_extract.py
========================================
import cv2
import pytesseract
import numpy as np
from pathlib import Path

pytesseract.pytesseract.tesseract_cmd = "/usr/bin/tesseract"

class NumberPlateExtractor:
    """Class to extract text from number plate images using pytesseract."""
    
    def __init__(self, tesseract_cmd=None):
        """
        Initialize the NumberPlateExtractor.
        
        Args:
            tesseract_cmd (str, optional): Path to tesseract executable if required.
        """
        if tesseract_cmd:
            pytesseract.pytesseract.tesseract_cmd = "/usr/bin/tesseract"
    
    def preprocess_plate(self, img):
        """Preprocess the number plate image to improve OCR accuracy.
        
        Args:
            img (np.ndarray): Input image of the number plate.
        
        Returns:
            np.ndarray: Preprocessed image.
        """
        try:
            # Convert to grayscale
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            # Apply adaptive thresholding
            thresh = cv2.adaptiveThreshold(
                gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                cv2.THRESH_BINARY_INV, 11, 2
            )
            # Apply slight Gaussian blur to reduce noise
            blurred = cv2.GaussianBlur(thresh, (3, 3), 0)
            return blurred
        except Exception as e:
            print(f"Error in preprocessing number plate: {e}")
            return None
    
    def extract_text(self, img):
        """Extract text from a number plate image using pytesseract.
        
        Args:
            img (np.ndarray): Input image of the number plate.
        
        Returns:
            str: Extracted text or None if extraction fails.
        """
        try:
            preprocessed = self.preprocess_plate(img)
            if preprocessed is None:
                print("Preprocessing returned None.")
                return None
            
            # Save preprocessed image for debugging
            cv2.imwrite("preprocessed_plate.jpg", preprocessed)
            print("Preprocessed image saved as preprocessed_plate.jpg")
            
            # Configure tesseract for alphanumeric characters
            custom_config = r'--oem 3 --psm 8 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
            text = pytesseract.image_to_string(preprocessed, config=custom_config)
            print(f"Raw OCR output: '{text}'")
            text = text.strip().replace('\n', '').replace(' ', '')
            
            # Basic validation: check if text is reasonable (e.g., length > 2)
            if len(text) > 2 and any(c.isalnum() for c in text):
                return text
            print("Text validation failed: too short or no alphanumeric characters.")
            return None
        except Exception as e:
            print(f"Error extracting text from number plate: {e}")
            return None
    
    def process_plate(self, img, box):
        """Crop the number plate region and extract text.
        
        Args:
            img (np.ndarray): Original image containing the number plate.
            box (list): Bounding box [x1, y1, x2, y2] for the number plate.
        
        Returns:
            str: Extracted number plate text or None if extraction fails.
        """
        try:
            x1, y1, x2, y2 = map(int, box)
            # Ensure coordinates are within image bounds
            x1, y1 = max(0, x1), max(0, y1)
            x2, y2 = min(img.shape[1], x2), min(img.shape[0], y2)
            if x2 <= x1 or y2 <= y1:
                print("Invalid bounding box dimensions.")
                return None
            
            # Crop the number plate region
            plate_img = img[y1:y2, x1:x2]
            if plate_img.size == 0:
                print("Empty cropped image.")
                return None
            
            # Save cropped image for debugging
            cv2.imwrite("cropped_plate.jpg", plate_img)
            print("Cropped image saved as cropped_plate.jpg")
            
            return self.extract_text(plate_img)
        except Exception as e:
            print(f"Error processing number plate: {e}")
            return None

if __name__ == "__main__":
    try:
        # Initialize the extractor with the correct Tesseract path
        extractor = NumberPlateExtractor(tesseract_cmd=r"/usr/bin/tesseract")
        
        # Load the sample image using absolute path
        sample_image_path = "../captured_images/car1.jpg"
        img = cv2.imread(sample_image_path)
        if img is None:
            print(f"Failed to load sample image: {sample_image_path}")
            exit(1)
        
        # Set bounding box to entire image size
        height, width = img.shape[:2]
        sample_box = [0, 0, width, height]
        print(f"Image dimensions: {width}x{height}, Using sample_box: {sample_box}")
        
        # Process the number plate
        plate_text = extractor.process_plate(img, sample_box)
        if plate_text:
            print(f"Extracted number plate text: {plate_text}")
        else:
            print("Failed to extract number plate text.")
            
    except Exception as e:
        print(f"Error in test: {e}")


